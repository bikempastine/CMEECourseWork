Starting code feedback for Bikem, Week3

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 2.57 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: week2, week3, .git, week1, Feedback

Found the following files in parent directory: .gitignore, README.md

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:

**********************************************************************
*~
*.tmp

.csv
.log

# Python
*.py[co]
__pycache__/

#Jupyter
.ipynb_checkpoints/

# R History files
.Rhistory
.Rapp.history

# R Session Data files
.RData

## Core latex/pdflatex auxiliary files:
*.aux
*.lof
*.log
*.lot
*.fls
*.out
*.toc
*.fmt
*.fot
*.cb
*.cb2
.*.lb

## Intermediate documents:
*.dvi
*.xdv
*-converted-to.*
# these rules might exclude image files for figures etc.
# *.ps
# *.eps
# *.pdf

## Generated if empty string is given at "Please type another file name for output:"
.pdf

## Bibliography auxiliary files (bibtex/biblatex/biber):
*.bbl
*.bcf
*.blg
*-blx.aux
*-blx.bib
*.run.xml

## Build tool auxiliary files:
*.fdb_latexmk
*.synctex
*.synctex(busy)
*.synctex.gz
*.synctex.gz(busy)
*.pdfsync

**********************************************************************

Found README in parent directory, named: README.md

Printing contents of README.md:

**********************************************************************
# My CMEE Coursework Repository

### Description
This is Bikem Pastine's repository for the Coputational Methods in Ecology and Evolution Master's program. Each week the repository will be updated with the coursework for the prvious week for marking. 

### Instructions
To check the weeks assignement, clone the directory for that week and run the code within the 'code' folder. The code may prompt for inputs. Appropriate example inputs can be found in the 'data' folder. The outupts of the code can be found in the 'results' folder once the code is run. 

### Contents
| Submission  |      Learning Objectives      |  Link |
|----------|:-------------:|------:|
| Week 1 |  UNIX and LINUX, Bash scripting, LaTeX | [here](https://github.com/bikempastine/CMEECourseWork/tree/main/week1) |
| Week 2 |   Biological Computing in Python    |   [here](https://github.com/bikempastine/CMEECourseWork/tree/main/week2) |

### Contact
Bikem Pastine: bp222@ic.ac.uk

Director for the CMEE is course: [mhasoba](https://github.com/mhasoba/TheMulQuaBio)
**********************************************************************

======================================================================
Looking for the weekly directories...

Found 3 weekly directories: week1, week2, week3

The Week3 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK3...

Found the following directories: code, data, results

Found the following files: .gitignore

Checking for readme file in weekly directory...

README file missing, 1 pt deducted

Current Points = 99

Results directory is empty - good! 

Found 27 code files: Girko.R, Vectorize1.R, TreeHeight.R, apply2.R, PP_Regress.R, browse.R, boilerplate.R, control_flow.R, DataWrangTidy.R, Vectorize2.R, PP_Dists.R, preallocate.R, try.R, MyBars.R, Ricker.R, break.R, apply1.R, basic_io.R, DataWrang.R, FloridaWriteup.tex, plotLin.R, GPDD_Data.R, Florida.R, next.R, sample.R, R_conditionals.R, testVectorize2.R

======================================================================
Testing script/code files...

======================================================================
Inspecting script file Girko.R...

File contents are:

**********************************************************************
# load required libraries
library(ggplot2)

# function producing elipse to bound eigenvalues
build_elipse <- function(hradius, vradius){
    npoints = 250
    a <- seq(0,2 *pi, length = npoints + 1) # sequence from zero to 2pi with 251 points
    x <- hradius * cos(a)
    y <- vradius *sin(a)
    return(data.frame(x = x, y = y))
}

# Create a maxtrix to find the eigen values of
N <- 250 #size of matrix
M <- matrix(rnorm(N*N), N, N) # create the matrix

# Find the eigen values
eigenvals <- eigen(M)$values

# Build the dataframe of the eigen values seperating out real and imaginary component
eigDF <- data.frame("Real" = Re(eigenvals), "Imaginary" = Im(eigenvals))
head(eigDF)

# Set radius of the elipse
my_radius <- sqrt(N)

#Dataframe of the elipse
ellDF <- build_elipse(my_radius, my_radius)
names(ellDF) <- c("Real", "Imaginary") #rename columns to match eigDF

##Plot results
#plot the eigenvalues
p <- ggplot(eigDF, aes(x = Real, y = Imaginary))+
            geom_point(shape = I(3))+
            theme_bw()+
            theme(legend.position = "none")

#add vertical and horizontal lines representing real, imaginary axis
p <- p + geom_hline(aes(yintercept = 0))+
         geom_vline(aes(xintercept = 0))

#add the elipse
p <- p + geom_polygon(data = ellDF, aes(x = Real, y = Imaginary, 
                                        alpha = 1/20, fill = "red"))

# Save to pdf in results
pdf("../results/Girko.pdf", width=10, height=10)
print(p)
dev.off()
**********************************************************************

Testing Girko.R...

Output (only first 500 characters): 


**********************************************************************
        Real  Imaginary
1 -14.201224   8.372983
2 -14.201224  -8.372983
3  15.292591   5.840746
4  15.292591  -5.840746
5  -9.009465  13.107129
6  -9.009465 -13.107129
null device 
          1 

**********************************************************************

Code ran without errors

Time consumed = 2.18265s

======================================================================
Inspecting script file Vectorize1.R...

File contents are:

**********************************************************************
# Script: Vectorize1.R
# sums all elements of a matrix

m<- matrix(runif(1000000), 1000, 1000)


SumAllElements <- function(m){
    Dimentions <- dim(m)
    Tot <- 0
    for (i in 1:Dimentions[1]) {
        for (j in 1:Dimentions[2]){
            Tot <- Tot + m[i,j]
        }
    }
    return(Tot)
}

print("Using loops, the time taken is:")
print(system.time(SumAllElements(m)))

print("Using the in-built vectorised function, the time taken is:")
print(system.time(sum(m)))
**********************************************************************

Testing Vectorize1.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Using loops, the time taken is:"
   user  system elapsed 
   0.14    0.00    0.14 
[1] "Using the in-built vectorised function, the time taken is:"
   user  system elapsed 
  0.003   0.000   0.003 

**********************************************************************

Code ran without errors

Time consumed = 0.61502s

======================================================================
Inspecting script file TreeHeight.R...

File contents are:

**********************************************************************
# An example utility function
# This functiom calculates heights of trees given the distance of each tree
# from its base and angle to its top, using trigonometric formula

# height = distance * tan(radians)

# Arguments=
# degrees: the angle of elevation of the tree
# distance: The distance from the base of the tree (meters)

# Output=
# The heights of the tree, same units as the distance argument

treesdata <- read.csv("../data/trees.csv") #read in the csv

#function to get tree heights using trig
TreeHeight <- function(degrees, distance) {
    radians <- degrees * pi / 180
    height <- distance * tan(radians)
    #print(paste("Tree height is:", height))
    #print(paste("Tree height is:", height))

    return (height)
}

#make a new column on treesdata with the results from the function
treesdata$Tree.Height.m<- TreeHeight(treesdata$Angle.degrees, treesdata$Distance.m)

#save the results in results
write.csv(treesdata, "../results/TreeHts.csv")
**********************************************************************

Testing TreeHeight.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.40757s

======================================================================
Inspecting script file apply2.R...

File contents are:

**********************************************************************
## Script: apply2.R
## Demonstrates the use own functions within apply functions

SomeOperation <- function(v) { #returns 100* the matrix if the sum of a matrix is positive
    if (sum(v) > 0) {
        return (v * 100)
    } else{
        return (v) 
    }
}

m <- matrix(rnorm(1000), 100 , 100)
print(apply(m,1,SomeOperation))

print(m)
**********************************************************************

Testing apply2.R...

Output (only first 500 characters): 


**********************************************************************
             [,1]      [,2]       [,3]       [,4]       [,5]       [,6]
  [1,]  2.0341980 -71.72266   24.53368 -18.675515 -1.3157730 -1.1139018
  [2,] -1.2111104 -65.91103   33.37063 140.999276 -0.9778785 -1.1259014
  [3,] -2.1327782  36.66587  -47.17054 218.339478  0.3457507 -1.0081700
  [4,]  0.3496133 -23.32029   54.51378 -77.447001  0.5948790  0.3378110
  [5,] -2.4713247 -51.13630  -50.13566  95.252541 -0.4460857  1.1714107
  [6,]  1.2314966 154.00242   35.43935 -75.619977  0.4810842 -0.41126
**********************************************************************

Code ran without errors

Time consumed = 0.49158s

======================================================================
Inspecting script file PP_Regress.R...

File contents are:

**********************************************************************
#load required packages
library(ggplot2)
library(dplyr)
library(broom)

#clean workspace
rm(list=ls())


#load the data
Pred <- as.data.frame(read.csv("../data/EcolArchives-E089-51-D1.csv"))

## Cleaning
#making prey mass data to be all in mg
mg<- filter(Pred, Prey.mass.unit == "mg") #get rows where prey mass unit is mg
mg$Prey.mass<- mg$Prey.mass *0.001 #multiply prey mass in these rows by 0.001 to convert to grams

# Join rows that had prey mass in g and ones that were originally in mg
Pred_prey_g <- rbind(mg, filter(Pred, Prey.mass.unit == "g"))


## Plotting
#plot the results in the style in the MulQUalBio
reproduced_predator<- ggplot(Pred_prey_g,  aes(Prey.mass,  Predator.mass,
        group = Predator.lifestage, col=Predator.lifestage)) +
  geom_point(pch=4) +
  geom_smooth(method = lm, fullrange=TRUE)+
  theme_bw()+
  theme(legend.position="bottom")+
  scale_x_continuous(trans = scales::log_trans(),
                     breaks = scales::log_breaks()) +
  scale_y_continuous(trans = scales::log_trans(),
                     breaks = scales::log_breaks())+
    xlab("Prey mass in grams")+
    ylab("Preditor mass in grams")+
  facet_wrap(~Type.of.feeding.interaction, nrow=5, strip.position= "right")

#write the plot to pdf in results
pdf("../results/reproduced_predator.pdf", width=6, height=12)
print(reproduced_predator)
dev.off()

## Storing results
#Perform the regression, first grouping by the required feilds
regression <- Pred_prey_g %>% 
                            group_by(Type.of.feeding.interaction,Predator.lifestage)%>%
                            do(reg_vals = summary(lm(log(Prey.mass) ~ log(Predator.mass), data=.))) #do function executes the regression in dplyr

#Get the list of groups that correspond to each regression output
reg_group_key<- Pred_prey_g %>% group_by(Type.of.feeding.interaction,Predator.lifestage)%>%
                group_keys()

#make a dataframe to put regression output into
reg_results <- data.frame(Type_of_feeding_interaction = character(),
                Predator_lifestage= character(),
                Intercept = double(), 
                Slope= double(), 
                F_stat= double(), 
                R2= double(), 
                Pvalue= double())


#Put in requird info from the reg//-group_key and the regression results
for(i in 1:18){
    reg_results[i,1]<- reg_group_key[i,1]
    reg_results[i,2]<- reg_group_key[i,2]
    reg_results[i,3]<- regression$reg_vals[[i]][[4]][1,1] #intercept
    reg_results[i,4]<- regression$reg_vals[[i]][[4]][2,1] #slope
    reg_results[i,5]<- regression$reg_vals[[i]][[10]][1] #F-stat
    reg_results[i,6]<- regression$reg_vals[[i]][[8]] #R2
    reg_results[i,7]<- regression$reg_vals[[i]][[4]][2,4] #p-value
}

#write results to csv and save in results
write.csv(reg_results, file= "../results/PP_Regress_Results.csv")


**********************************************************************

Testing PP_Regress.R...

Output (only first 500 characters): 


**********************************************************************
null device 
          1 

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***


Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

`geom_smooth()` using formula 'y ~ x'
Warning messages:
1: In qt((1 - level)/2, df) : NaNs produced
2: In max(ids, na.rm = TRUE) :
  no non-missing arguments to max; returning -Inf

======================================================================
Inspecting script file browse.R...

File contents are:

**********************************************************************
# Script: browse.R
# demonstrates debugging tools in R

Exponential <- function(N0 = 1, r =1, generations =10){
    #simulation of exponential growth
    N <- rep(NA, generations) #creates a vector of NAs, length generations

    N[1] <- N0
    for (t in 2:generations) {
        N[t] <- N[t-1] * exp(r)
        #browser()
    }
    return (N)
}

plot(Exponential(), type="l", main="Exponential growth")
**********************************************************************

Testing browse.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.49832s

======================================================================
Inspecting script file boilerplate.R...

File contents are:

**********************************************************************
# A boilerplate R script

MyFunction <- function(Arg1, Arg2) {
    print(paste("Argument", as.character(Arg1), "is a", class(Arg1)))
    print(paste("Argument", as.character(Arg2), "is a", class(Arg2)))

    return(c(Arg1, Arg2))
}

MyFunction(1,2)
MyFunction('riki', 1)
**********************************************************************

Testing boilerplate.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Argument 1 is a numeric"
[1] "Argument 2 is a numeric"
[1] 1 2
[1] "Argument riki is a character"
[1] "Argument 1 is a numeric"
[1] "riki" "1"   

**********************************************************************

Code ran without errors

Time consumed = 0.44679s

======================================================================
Inspecting script file control_flow.R...

File contents are:

**********************************************************************
#!/usr/bin/Rscript
#Control Flows

#if statements
a <- TRUE
if(a==TRUE){
    print("a is TRUE")
} else{
    print("a is false")
}

z <- runif(1)
if (z <= 0.5) {print("Less than 0.5")}


#for loops
for (i in 1:10){j <- i * i
    print(paste(i , 'squared is', j))
}

for(species in c('Heliodoxa rubinoides', 
                 'Boissonneaua jardini', 
                 'Sula nebouxii')) {
                    print(paste('The species is', species))
                 }

#while loops
i <- 0
while (i < 10){
    i <- i+1
    print(i^2)
}
**********************************************************************

Testing control_flow.R...

Output (only first 500 characters): 


**********************************************************************
[1] "a is TRUE"
[1] "Less than 0.5"
[1] "1 squared is 1"
[1] "2 squared is 4"
[1] "3 squared is 9"
[1] "4 squared is 16"
[1] "5 squared is 25"
[1] "6 squared is 36"
[1] "7 squared is 49"
[1] "8 squared is 64"
[1] "9 squared is 81"
[1] "10 squared is 100"
[1] "The species is Heliodoxa rubinoides"
[1] "The species is Boissonneaua jardini"
[1] "The species is Sula nebouxii"
[1] 1
[1] 4
[1] 9
[1] 16
[1] 25
[1] 36
[1] 49
[1] 64
[1] 81
[1] 100

**********************************************************************

Code ran without errors

Time consumed = 0.48903s

======================================================================
Inspecting script file DataWrangTidy.R...

File contents are:

**********************************************************************

### Wrangling the Pound Hill Dataset using tidyverse

#load required packages
library(tidyverse)

############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../data/PoundHillData.csv", header = FALSE))

# header = true because we do have metadata headers
MyMetaData <- read.csv("../data/PoundHillMetaData.csv", header = TRUE, sep = ";")

############# Inspect the dataset ###############
head(MyData)
dim(MyData)
str(MyData) 

############# Transpose ###############
# To get those species into columns and treatments into rows 

MyData <- MyData %>% t() %>% as.data.frame() %>% #transpose data and save as a df
                    setNames(.[1,])%>% #set column names
                    slice(-1)%>% #get rid of first row : duplicate
                    mutate_all(funs(replace(., .=='', 0)))#%>% #replace blank cells with 0       




############# Convert from wide to long format  ###############
MyWrangledData<- MyData %>% pivot_longer(cols = 5:45,
                             names_to = "Species", values_to = "Count")


#convert to correct data type
MyWrangledData <- MyWrangledData %>% 
                    mutate(across(Cultivation:Quadrat, as.factor)) %>% 
                    mutate(across(Count, as.integer))





**********************************************************************

Testing DataWrangTidy.R...

Output (only first 500 characters): 


**********************************************************************
     V1                     V2        V3        V4        V5        V6       
[1,] "Cultivation"          "october" "october" "october" "october" "october"
[2,] "Block"                "a"       "a"       "a"       "a"       "a"      
[3,] "Plot"                 "1"       "1"       "1"       "1"       "1"      
[4,] "Quadrat"              "Q1"      "Q2"      "Q3"      "Q4"      "Q5"     
[5,] "Achillea millefolium" "4"       "8"       "3"       "20"      "6"      
[6,] "Agrostis gigantea"    ""   
**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──
✔ ggplot2 3.3.5     ✔ purrr   0.3.5
✔ tibble  3.1.8     ✔ dplyr   1.0.8
✔ tidyr   1.2.0     ✔ stringr 1.4.1
✔ readr   2.1.2     ✔ forcats 0.5.1
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
Warning message:
`funs()` was deprecated in dplyr 0.8.0.
Please use a list of either functions or lambdas: 

  # Simple named list: 
  list(mean = mean, median = median)

  # Auto named with `tibble::lst()`: 
  tibble::lst(mean, median)

  # Using lambdas
  list(~ mean(., trim = .2), ~ median(., na.rm = TRUE)) 

======================================================================
Inspecting script file Vectorize2.R...

File contents are:

**********************************************************************
# Runs the stochastic Ricker equation with gaussian fluctuations

rm(list = ls())

stochrick <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears = 100)
{

  N <- matrix(NA, numyears, length(p0))  #initialize empty matrix

  N[1, ] <- p0

  for (pop in 1:length(p0)) { #loop through the populations

    for (yr in 2:numyears){ #for each pop, loop through the years

      N[yr, pop] <- N[yr-1, pop] * exp(r * (1 - N[yr - 1, pop] / K)+ rnorm(1, 0, sigma)) # add one fluctuation from normal distribution
    
     }
  
 }
 return(N)

}


# Now write another function called stochrickvect that vectorizes the above to
# the extent possible, with improved performance: (currently sme speed or slower :( )

stochrickvect<- function(x, p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears = 100)
{
  N <- matrix(NA, numyears, length(p0)) 
  N[1, ] <- p0

  recurssive <- function(x){
    for (yr in 2:numyears){# loop through years, can't get rid of this becuase uses previous val
      x[yr] <- x[yr-1] * exp(r * (1 - x[yr - 1] / K)+ rnorm(1, 0, sigma)) # add one fluctuation from normal distribution
    }
    return(x)}

  test_val <- apply(N, 2, recurssive)
  return(test_val)

  }
 

  
print("Vectorized Stochastic Ricker takes:")
print(system.time(res2<-stochrickvect()))

**********************************************************************

Testing Vectorize2.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Vectorized Stochastic Ricker takes:"
   user  system elapsed 
  0.657   0.029   0.686 

**********************************************************************

Code ran without errors

Time consumed = 1.11337s

======================================================================
Inspecting script file PP_Dists.R...

File contents are:

**********************************************************************
#load required packages
library(tidyverse)

#clean workspace
rm(list=ls())

#load the data
Pred_data <- as.data.frame(read.csv("../data/EcolArchives-E089-51-D1.csv"))

## Cleaning
#making prey mass data to be all in mg
mg<- filter(Pred_data, Prey.mass.unit == "mg") #get rows where prey mass unit is mg
mg$Prey.mass<- mg$Prey.mass *0.001 #multiply prey mass in these rows by 0.001 to convert to grams

# Join rows that had prey mass in g and ones that were originally in mg
Pred_data_g <- rbind(mg, filter(Pred_data, Prey.mass.unit == "g"))


#Make dataframe for plotting
DF <- Pred_data_g %>% 
                group_by(Type.of.feeding.interaction)%>% #groups
                select(Type.of.feeding.interaction, #select ony required columns to avoid confusion  
                        Predator.mass, Prey.mass)


#add column for size ratio
DF$Size.ratio <- DF$Predator.mass / DF$Prey.mass

#Spliteach group into its own tibble, stored in a list
a<- DF %>% group_split()

#Histogram plotting function
plot.my.hist <- function(x,y, name, max, min, step){
    hist(log10(x),
     xlab = paste("log10(", name, " )"), 
     ylab = "Count", 
     col = "lightblue",
     main = y,
     xlim = c(min,max),
     breaks = seq(from= min , to= max, by=step)
     )}


##Plot results and save in results
#Predator
pdf("../results/Pred_Subplots.pdf", width=6, height=12)
par(mfrow=c(5,1))
for(i in 1:5){
    plot.my.hist(pull(a[[i]][2]), 
                pull(a[[i]][1,1]),
                name = "Predator Mass (g)",
                max = 6 , min = -4, step = 1)
}
dev.off()

#Prey
pdf("../results/Prey_Subplots.pdf", width=6, height=12)
par(mfrow=c(5,1))
for(i in 1:5){
    plot.my.hist(pull(a[[i]][3]), 
                pull(a[[i]][1,1]),
                name = "Prey Mass (g)",
                max = 4 , min = -11, step = 1)
}
dev.off()

#Size Ratio
pdf("../results/SizeRatio_Subplots.pdf", width=6, height=12)
par(mfrow=c(5,1))
for(i in 1:5){
    plot.my.hist(pull(a[[i]][4]), 
                pull(a[[i]][1,1]),
                name = "Size ratio:\n(Predator mass/Pret mass)",
                max = 9 , min = -3, step = 1)
}
dev.off()

##Results as csv
#summarize the results by group , making new columns for each summary
table.results <- DF%>%
        summarize(Mean.Predator = mean(log10(Predator.mass)),
                  Median.Predator = median(log10(Predator.mass)),      
                  Mean.Prey = mean(log10(Prey.mass)),      
                  Median.Prey = median(log10(Prey.mass)),
                  Mean.SizeRatio = mean(log10(Size.ratio)),
                  Median.SizeRatio = median(log10(Size.ratio)))

#rename first column
table.results<- table.results%>% rename("Feeding.type" = "Type.of.feeding.interaction")

#write results to csv
write.csv(table.results, "../results/PP_Results.csv")            
**********************************************************************

Testing PP_Dists.R...

Output (only first 500 characters): 


**********************************************************************
null device 
          1 
null device 
          1 
null device 
          1 

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──
✔ ggplot2 3.3.5     ✔ purrr   0.3.5
✔ tibble  3.1.8     ✔ dplyr   1.0.8
✔ tidyr   1.2.0     ✔ stringr 1.4.1
✔ readr   2.1.2     ✔ forcats 0.5.1
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()

======================================================================
Inspecting script file preallocate.R...

File contents are:

**********************************************************************
# Script: preallocate.R
# Demonstrates how pre-allocation of memmory can speed up R code

## By appending (no pre-allocation)
NoPrealloFun <- function(x) {
    a <- vector() #empty vector
    for (i in 1:x) {
        a <- c(a, i) #append i to existing vector 'a'
        #print(a)
        #print(object.size(a))
    }
}

print(system.time(NoPrealloFun(1000)))

## By pre-allocating
PreallocFun <- function(x) {
    a <- rep(NA, x) #vector of 'x' size, filled with NAs
    for (i in 1:x){
        a[i] <- i #assign 'i' into the 'i'th space
        #print(a)
        #print(object.size(a))
    }
}

print(system.time(PreallocFun(1000)))
**********************************************************************

Testing preallocate.R...

Output (only first 500 characters): 


**********************************************************************
   user  system elapsed 
  0.027   0.000   0.026 
   user  system elapsed 
  0.004   0.000   0.005 

**********************************************************************

Code ran without errors

Time consumed = 0.43018s

======================================================================
Inspecting script file try.R...

File contents are:

**********************************************************************
# Script: try.R
# practicing the try keyword

doit <- function(x) {
    temp_x <- sample(x, replace = TRUE)
    if(length(unique(temp_x)) > 30){#take mean if number of unique values in the sample is over 30
        print(paste("Mean of this sample was:", as.character(mean(temp_x))))

    }
    else{
        stop("Couldn't calculate mean: too few unique values")
    }
}

set.seed(1345)
popn <- rnorm(50)
hist(popn)

# lapply(1:15, function(i) doit(popn)) #returns an error

result<- lapply(1:15, function(i) try(doit(popn), FALSE))
class(result)

## Use a loop to do the same
result <- vector("list", 15)
for(i in 1:15){
    result[[i]] <- try(doit(popn), FALSE)
}
**********************************************************************

Testing try.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Mean of this sample was: -0.11620822588674"
[1] "Mean of this sample was: -0.0468516755995931"
[1] "Mean of this sample was: -0.0890228211466614"
[1] "Mean of this sample was: -0.124229742255296"
[1] "Mean of this sample was: 0.0314144452816157"
[1] "Mean of this sample was: -0.233476945796405"
[1] "Mean of this sample was: -0.196681538928001"
[1] "Mean of this sample was: 0.0146969612111605"
[1] "Mean of this sample was: -0.234913159471725"
[1] "Mean of this sample was: -0.0497464588165691"
**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Error in doit(popn) : Couldn't calculate mean: too few unique values
Error in doit(popn) : Couldn't calculate mean: too few unique values
Error in doit(popn) : Couldn't calculate mean: too few unique values
Error in doit(popn) : Couldn't calculate mean: too few unique values
Error in doit(popn) : Couldn't calculate mean: too few unique values

======================================================================
Inspecting script file MyBars.R...

File contents are:

**********************************************************************
##Learning to plot lineranges (or boxes) in ggplot

#Load required packages
library(ggplot2)

#load data
a <- read.table("../data/Results.txt", header = TRUE)
head(a) #view data

# append on a column of zeros
a$ymin <- rep(0, dim(a)[1])

#plot first linerange
p <- ggplot(a) + geom_linerange(data = a, aes(x=x, ymin = ymin,
                                            ymax = y1, size = 0.5),
                                colour = "#E69F00", alpha = 0.5, 
                                show.legend = FALSE)

#plot second linerange
p <- p + geom_linerange(data = a, aes(x = x, ymin = ymin,
                                    ymax = y2,size = 0.5),
                        colour = "#56B4E9", alpha = 0.5, 
                        show.legend = FALSE)

#plot third linerange:
p <- p + geom_linerange(data = a, aes(x = x, ymin = ymin,
                                    ymax = y3, size = 0.5),
                        colour = "#D55E00", alpha = 0.5, 
                        show.legend = FALSE)

#add labels
p <- p + geom_text(data = a, aes(x = x, y = -500, label = Label))

#set axis labels and add theme
p <- p + scale_x_continuous("My x axis",breaks = seq(3, 5, by = 0.05)) +
            scale_y_continuous("My y axis") +
            theme_bw()


#save as pdf

pdf("../results/MyBars.pdf", width=10, height=10)
print(p)
dev.off()
**********************************************************************

Testing MyBars.R...

Output (only first 500 characters): 


**********************************************************************
         x   y1   y2 y3 Label
1 3.515424 4320 4320  0  <NA>
2 3.533984 2160 2160  0  <NA>
3 3.557647 4320 4320  0  <NA>
4 3.569953 4320 4320  0  <NA>
5 3.578984 8640 8640  0  <NA>
6 3.585665 2160 2160  0  <NA>
null device 
          1 

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Warning message:
Removed 91 rows containing missing values (geom_text). 

======================================================================
Inspecting script file Ricker.R...

File contents are:

**********************************************************************
# Script: Ricker.R
# Ricker model: population model
Ricker <- function(N0=1, r=1, K=10, generations=50) {
    #Returns a vector of the length of generations

    N <- rep(NA, generations)

    N[1] <- N0
    for(t in 2: generations){
        N[t] <- N[t-1] * exp(r*(1.0 - (N[t-1]/K)))
    }
    return(N)
}

plot(Ricker(generations=10) , type= "l")
**********************************************************************

Testing Ricker.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.59162s

======================================================================
Inspecting script file break.R...

File contents are:

**********************************************************************
#!/usr/bin/Rscript
#Breaking out of loops

i<- 0 #initialising i

while(i < Inf){
    if (i == 10){
        break
    }else{
        cat("i equals", i, "\n")
        i <- i +1 #updating i to the next itteration 
    }
}
**********************************************************************

Testing break.R...

Output (only first 500 characters): 


**********************************************************************
i equals 0 
i equals 1 
i equals 2 
i equals 3 
i equals 4 
i equals 5 
i equals 6 
i equals 7 
i equals 8 
i equals 9 

**********************************************************************

Code ran without errors

Time consumed = 0.50684s

======================================================================
Inspecting script file apply1.R...

File contents are:

**********************************************************************
# Script: apply1.R
# Learning about the apply family of functions in R

## Build a random matrix
m <- matrix(rnorm(100), 10, 10)

## Take the means of each row
RowMeans <- apply(m, 1, mean)
print(RowMeans)

## Take the variance of each row
RowVars <- apply(m, 1, var)
print(RowVars)

## Take the means of each column
ColMeans <- apply(m,2,mean)
print(ColMeans)
**********************************************************************

Testing apply1.R...

Output (only first 500 characters): 


**********************************************************************
 [1]  0.5663726 -0.2136624  0.6186356  0.6311600 -0.4222371 -0.6703191
 [7] -0.5675515  0.2482734  0.2874412 -0.1519482
 [1] 2.1422719 0.5251600 1.2560840 0.8613769 0.9769030 0.9947589 1.1468380
 [8] 1.1955524 2.2674897 0.5746506
 [1] -0.281885524 -0.148418192 -0.303435137 -0.230397937  0.264780194
 [6]  0.392131809 -0.113749986  0.421817028  0.003445937  0.321876238

**********************************************************************

Code ran without errors

Time consumed = 0.44886s

======================================================================
Inspecting script file basic_io.R...

File contents are:

**********************************************************************
# A simple R script to illustrate R input-output.   
# Run line by line and check inputs outputs to understand what is happening  

MyData <- read.csv("../data/trees.csv", header = TRUE) # import with headers

write.csv(MyData, "../results/MyData.csv") #write it out as a new file

write.table(MyData[1,], file = "../results/MyData.csv",append=TRUE) # Append to it

write.csv(MyData, "../results/MyData.csv", row.names=TRUE) # write row names

write.table(MyData, "../results/MyData.csv", col.names=FALSE) # ignore column names

**********************************************************************

Testing basic_io.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error (or warning):

***IGNORE IF THIS ERROR IS EXPECTED AS PART OF AN IN-CLASS EXERCISE***

Warning message:
In write.table(MyData[1, ], file = "../results/MyData.csv", append = TRUE) :
  appending column names to file

======================================================================
Inspecting script file DataWrang.R...

File contents are:

**********************************************************************
################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################

############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../data/PoundHillData.csv", header = FALSE))

# header = true because we do have metadata headers
MyMetaData <- read.csv("../data/PoundHillMetaData.csv", header = TRUE, sep = ";")

############# Inspect the dataset ###############
head(MyData)
dim(MyData)
str(MyData) #why??
fix(MyData) #you can also do this
fix(MyMetaData)

############# Transpose ###############
# To get those species into columns and treatments into rows 
MyData <- t(MyData) 
head(MyData)
dim(MyData)
fix(MyData)

############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0

############# Convert raw matrix to data frame ###############

TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #stringsAsFactors = F is important!
colnames(TempData) <- MyData[1,] # assign column names from original data
head(TempData)

############# Convert from wide to long format  ###############
require(reshape2) # load the reshape2 package

?melt #check out the melt function

MyWrangledData <- melt(TempData, id=c("Cultivation", "Block", "Plot", "Quadrat"), variable.name = "Species", value.name = "Count")
fix(MyWrangledData)
class(MyWrangledData$Block)
MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])

str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)

############# Exploring the data (extend the script below)  ###############

require(tidyverse)
#converting dataframe into a tibble
MyWrangledData <- as_tibble(MyWrangledData)
MyWrangledData
class(MyWrangledData)

glimpse(MyWrangledData)

View(MyWrangledData) #like fix but in tidyverse

filter(MyWrangledData, Count>100) #like subset

slice(MyWrangledData, 10:15)

MyWrangledData %>% group_by(Species) %>% 
        summarise(avg =mean(Count))

#same as
aggregate(MyWrangledData$Count, list(MyWrangledData$Species), FUN=mean) 

# Visualisation 
library(ggplot2)

# histogram of species abundance, grouped by cultivation
abundance_by_cultivation <- MyWrangledData %>% 
        group_by(Cultivation)%>% 
        ggplot( aes(x = log(Count))) +
        geom_histogram(fill = "lightblue", colour = "black") +
        theme_bw()+
        facet_grid(Cultivation ~ .)+
        labs(x = "Species Abundance",
        y = "Count of plots" ,
        title = "Species abundance by cultivation month")

#Bar plot of the number of tree species and number of trees observed of each species
spec<- MyWrangledData %>% group_by( Species)%>%  summarize(total = sum(Count))
ggplot(data = spec ,aes(y = total, x= reorder(Species, total))) +
        geom_bar(stat="identity", fill = 'steelblue')+
        theme_bw()+ coord_flip() + labs(x = 'total observed',
        y = 'Tree species', title = 'Number of tree species')




**********************************************************************

Testing DataWrang.R...

Output (only first 500 characters): 


**********************************************************************
     V1                     V2        V3        V4        V5        V6       
[1,] "Cultivation"          "october" "october" "october" "october" "october"
[2,] "Block"                "a"       "a"       "a"       "a"       "a"      
[3,] "Plot"                 "1"       "1"       "1"       "1"       "1"      
[4,] "Quadrat"              "Q1"      "Q2"      "Q3"      "Q4"      "Q5"     
[5,] "Achillea millefolium" "4"       "8"       "3"       "20"      "6"      
[6,] "Agrostis gigantea"    ""   
**********************************************************************

Code ran without errors

Time consumed = 10.01165s

======================================================================
Inspecting script file FloridaWriteup.tex...

File contents are:

**********************************************************************
\documentclass[11pt]{article}
\usepackage{graphicx}
\usepackage[margin=1cm]{geometry}
\graphicspath{ {../results/} }


\title{Is Florida getting warmer?}
\date{\vspace{-2cm}}

\begin{document}
  \maketitle
  
Global climate change altered the average climate in many places during the 20th century. 
A statistical investigation reveals that the average annual temperature increased in Key West, 
Florida during the 20th century. 
This increase is highly unlikely (p-value $<$ 0.05) to have occured if 
there were no correlation between temperatures and time.

\begin{figure}[h!]
  \centering
  \includegraphics[scale=0.4]{temp.png}
  %\caption{Temperatures in Key West, Florida in the 20th century}
  \label{fig:temps}
\end{figure}

There is a positive correlation between time and temperature as can be seen in Figure 1.
This means that the average annual temperature increased in the 20th century. 
To attribute this trend to a true warming rather than chance, statistical significance of the 
correlation coefficient is tested. If the correlation is insignificant,
the correlation can be attributed to chance coincedance rather than to climate change.

To calculate the p-value, a permutation analyis is performed.
A standard t-test is not appropriate because time series data is not independent.
The temperature data is ordered randomly using the 'sample' function in R 100,000 times. 
The correlation coeffiecent of each randomized time series is computed to 
produce a probability distriution for the correlation coefficients. 
The observed correlation coefficient is compared to the probability density function.

\begin{figure}[h!]
  \centering
  \includegraphics[scale = 0.4]{density.png}
  %\caption{Distribution of generated correlation coefficients}
  \label{fig:distribution}
\end{figure}

A corrrelation coefficient as high as 0.53 did not occur at all in all 100,000 random permutations of the 
time series as can be seen in Figure 2. This means that such a high 
correlation between time and temperature is highly unlikely (p-value $<$$<$ 0.05) to have occured by chance. 
It can be concluded that Key West, Florida got warmer in the 20th century.



\end{document}
**********************************************************************

Testing FloridaWriteup.tex...

======================================================================
Inspecting script file plotLin.R...

File contents are:

**********************************************************************
# Mathematical Display

#load required packages
library(ggplot2)

x <- seq(0, 100 , by = 0.1)
y <- -4 + 0.25 * x + 
        rnorm(length(x), mean = 0., sd = 2.5)

# add in a dataframe
my_data <- data.frame(x = x, y = y)

# perform linear regression
my_lm <- summary(lm(y ~ x, data = my_data))

# plot the data
p <- ggplot(my_data, aes(x = x, y = y,
            colour = abs(my_lm$residual))) +
    geom_point() +
    scale_colour_gradient(low = "black", high = "red") +
    theme(legend.position = "none") +
    scale_x_continuous(expression(alpha^2 * pi / beta * sqrt(Theta)))

# add the regression line
p <- p + geom_abline(intercept = my_lm$coefficients[1][1],
        slope = my_lm$coefficients[2][1], colour = "red")

# Add maths label to the plot
p <- p + geom_text(aes(x = 60, y = 0,
        label = "sqrt(alpha) * 2* pi"),
        parse = TRUE, size = 6,
        colour = "blue")


# Save plot in results

pdf("../results/MyLinReg.pdf", width=10, height=10)
print(p)
dev.off()
**********************************************************************

Testing plotLin.R...

Output (only first 500 characters): 


**********************************************************************
null device 
          1 

**********************************************************************

Code ran without errors

Time consumed = 2.17545s

======================================================================
Inspecting script file GPDD_Data.R...

File contents are:

**********************************************************************
#install.packages("maps")
library(maps)


#load in data
load("../data/GPDDFiltered.RData")

#basic info about the data
head(gpdd)
summary(gpdd)

#map the data on a world map
map("world",  fill= T, col = "lightgreen", interior = FALSE, border='darkgreen')
points(x = gpdd$long , y =gpdd$lat, col='red', cex= 0.8, pch= 19)
box()

#Looking at the map, what biases might you expect in any analysis based on the data represented?

# There is a strong northern hemisphere biases in the data : the mean latitude  is 48.88 degrees
# and the 1st Quartile latitude is 43,50 degrees. Furthermore, there is also a longitudinal bias.
# There is little data collected in the Asian continent while most of the data is collected in Europe
# and North America. For a database called the 'Global Population Dynamics Database', the spatial biases 
# are clear. This will impact how globally applicable the analyses of this data are.
**********************************************************************

Testing GPDD_Data.R...

Output (only first 500 characters): 


**********************************************************************
             common.name   lat    long
1        Atlantic salmon 60.00   10.00
2            Pink salmon 45.62 -121.97
3              Great tit 51.63    1.08
4 Eurasian oystercatcher 51.70   -5.15
5                Skylark 51.70   -5.15
6               Starling 51.70   -5.15
                      common.name      lat              long        
 Sockeye salmon             :15   Min.   :-28.75   Min.   :-135.00  
 Dungeness crab             :11   1st Qu.: 43.50   1st Qu.:-112.50  
 Fox                 
**********************************************************************

Code ran without errors

Time consumed = 1.01415s

======================================================================
Inspecting script file Florida.R...

File contents are:

**********************************************************************
# Load florida temperature data
rm(list=ls())
load("../data/KeyWestAnnualMeanTemperature.RData")
ls() #data called ats

#examine the data
class(ats)
head(ats)
summary(ats)

#plot the temperature data
png(file="../results/temp.png", width=500, height=450)
plot(ats, pch=19, cex= 0.8, ylab= "Average Annaual Temprature (°C)",
    main= "Fig 1: Temperatures in Key West, Florida in the 20th century") #relationship appears linear
abline(lm(ats$Temp ~ ats$Year), col = "red", lwd = 3)
text(paste("Correlation:", round(cor(ats$Temp, ats$Year), 2)), x = 1915, y = 25.8)
dev.off()

#correlation coefficient of actual data

hist(ats$Temp) #temperature appears somewhat normal 
floridacor<- cor(ats$Year, ats$Temp, method= 'pearson') 

#randomly reshuffle temperatures and find the corelation coefficient between years and reshuffled
reps = 100000
set.seed(2489)
cormatrix<- matrix(NA, nrow= reps, ncol=1)
for (i in 1:reps){
    temp<- sample(ats$Temp, replace= F)
    corcoeff<- cor(ats$Year, temp, method= 'pearson')
    cormatrix[i]<- corcoeff
}

# explore this cor coef data
summary(cormatrix)
hist(cormatrix)

# fraction of the random correlation coefficients were greater than the observed one
aprox_pvalue<- sum(cormatrix > floridacor)/ reps
paste("approximate, asymtomatic p-value is:", aprox_pvalue)


d <- density(cormatrix ,from=-1, to=1) # returns the density data


png(file="../results/density.png", width=500, height=450)
plot(d, xlim= c(-0.6,0.6), lwd= 3, #cex.lab=1.5, cex.axis=1.5, cex.main=1.5,,
        xlab = "Pearson Correlation Coefficient",
        ylab = "Probability Density",
        main = "Fig 2: Probability density distribion of randomly\npermutated temperature time series"
        )
polygon(d, border= 'black', col = 'lightgray')
abline(v= floridacor, col ='red' ,lty=2, lwd=3)
text(x =(floridacor - 0.16), y= 2, "observed\ncorrelation\ncoefficient", 
    col= 'red')
dev.off() 
**********************************************************************

Testing Florida.R...

Output (only first 500 characters): 


**********************************************************************
[1] "ats"
[1] "data.frame"
  Year     Temp
1 1901 23.75000
2 1902 24.66667
3 1903 24.71667
4 1904 24.51667
5 1905 24.88333
6 1906 24.63333
      Year           Temp      
 Min.   :1901   Min.   :23.75  
 1st Qu.:1926   1st Qu.:24.99  
 Median :1950   Median :25.29  
 Mean   :1950   Mean   :25.31  
 3rd Qu.:1975   3rd Qu.:25.62  
 Max.   :2000   Max.   :26.35  
null device 
          1 
       V1            
 Min.   :-0.4222104  
 1st Qu.:-0.0679907  
 Median : 0.0002781  
 Mean   : 0.0002069  
 3
**********************************************************************

Code ran without errors

Time consumed = 7.53347s

======================================================================
Inspecting script file next.R...

File contents are:

**********************************************************************
#!/usr/bin/Rscript
#Skipping itterations of a loop

for (i in 1:10) { #for 1 through 10
    if ((i %% 2) == 0) #if i is divisable by two
     next # skip that itteration 
    print(i) # print i otherwise
}
**********************************************************************

Testing next.R...

Output (only first 500 characters): 


**********************************************************************
[1] 1
[1] 3
[1] 5
[1] 7
[1] 9

**********************************************************************

Code ran without errors

Time consumed = 0.49746s

======================================================================
Inspecting script file sample.R...

File contents are:

**********************************************************************
## Script: sample.R

#######Functions##########

## Take the sample of size 'n' from a population 'popn' and return its mean
myexperiment <- function(popn, n) {
    pop_sample <- sample(popn, n , replace = FALSE)
    return(mean(pop_sample))
}

## Calculate means using a FOR loop on a vector without preallocation
loopy_sample1 <- function(popn,n,num){
    result1<- vector()
    for(i in 1:num){
        result1<- c(result1, myexperiment(popn, n))
    }
    return(result1)
}

## Run 'num' iterations of the experiment using FOR loop on vector with preallocation
loopy_sample2 <- function(popn, n, num) {
    result2 <- vector(,num) #preallocate
    for(i in 1:num){
        result2[i] <- myexperiment(popn,n)
    }
    return(result2)
}

## Run "num" iterations of the experiment using a FOR loop on a list with preallocation
loopy_sample3<- function(popn, n, num){
    result3<- vector('list', num) #preallocate 
    for(i in 1:num){
        result3[[i]]<- myexperiment(popn,n)
    }
    return(result3)
}

## Use vectorisation with lapply
lapply_sample <- function(popn, n, num){
    result4 <- lapply(1:num, function(i) myexperiment(popn, n))
    return(result4)
}

## Use vectorisation wih sapply
sapply_sample <- function(popn, n, num){
    result5<- sapply(1:num, function(i) myexperiment(popn, n ))
    return(result5)
}

#######Generate a population########
set.seed(12345)
popn <- rnorm(10000)
hist(popn)

n<- 100
num<- 10000

#######Running and time different functions##########

print("Using loops without preallocation on a vector:")
print(system.time(loopy_sample1(popn, n, num)))

print("Using loops with preallocation on a vector:")
print(system.time(loopy_sample2(popn, n, num)))

print("Using loops with preallocation on a list:")
print(system.time(loopy_sample3(popn, n, num)))

print("Using the vectorised sapply function on a list:")
print(system.time(sapply_sample(popn, n, num)))

print("Using the vectorised lapply function on a list:")
print(system.time(lapply_sample(popn, n, num)))
**********************************************************************

Testing sample.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Using loops without preallocation on a vector:"
   user  system elapsed 
  0.605   0.048   0.653 
[1] "Using loops with preallocation on a vector:"
   user  system elapsed 
  0.367   0.000   0.368 
[1] "Using loops with preallocation on a list:"
   user  system elapsed 
  0.425   0.000   0.424 
[1] "Using the vectorised sapply function on a list:"
   user  system elapsed 
  0.412   0.000   0.412 
[1] "Using the vectorised lapply function on a list:"
   user  system elapsed 
  0.393   0.000  
**********************************************************************

Code ran without errors

Time consumed = 2.95160s

======================================================================
Inspecting script file R_conditionals.R...

File contents are:

**********************************************************************
#Learning about functions with conditionals

#check if an integer is even
is.even <- function(n=2){
    if(n%% 2 == 0){
        return(paste(n, 'is even'))
    } else{
        return(paste(n, 'is odd!'))
    }
}

is.even(6)

#checks if a number is a power of 2
is.power2 <- function(n = 2){
    if(log2(n) %% 1 ==0){
        return(paste(n,'is a power of 2!')) #take the log base 2 of n and check if its a whole number
    } else {
        return(paste(n, 'is not a power of 2!'))
    }
}

is.power2(4)

#Checks if a number is prime
is.prime<- function(n) {
    if(n==0){
        return(paste(n, 'is a zero!'))
    }else if (n==1){
        return(paste(n, 'is a unit!'))
    }
    ints <- 2:(n-1)

    if (all(n%%ints!=0)){ #check if n indivisable by anything in integers (int)
        return(paste(n,'is a prime!')) 
    }else{
        return(paste(n,'is a composite!'))
    }
}

is.prime(3)
**********************************************************************

Testing R_conditionals.R...

Output (only first 500 characters): 


**********************************************************************
[1] "6 is even"
[1] "4 is a power of 2!"
[1] "3 is a prime!"

**********************************************************************

Code ran without errors

Time consumed = 0.42663s

======================================================================
Inspecting script file testVectorize2.R...

File contents are:

**********************************************************************
rm(list = ls())

stochrick <- function(p0 = runif(1000, .5, 1.5), r = 1.2, K = 1, sigma = 0.2,numyears = 100)
{
    N<- matrix(NA, numyears, length(p0))
    N[1,]<- p0
    
    for (x in 2:numyears){
        N[x, ] <- N[x-1, ] * exp(r * (1 - N[x-1,] / K)+ rnorm(1, 0, sigma))
    }


    return(N)
}



stochrick(numyears=10)

print(system.time(res2<-stochrick()))

library(data.table)

x<- 1:5
shift(x, n=1, fill=NA, type="lag")

N<- matrix(NA, 10, 1)
N[1,]<- runif(1, .5, 1.5)
N[2,]<- 3

trial<- function(data){
    data<- shift(data, n=1, fill=NA, type="lag")+ 1
    return(data)
}
function(N){
    shift(N, fill=0, type='lag') * exp(r * (1 - shift(N, fill=0, type='lag') / K)+ rnorm(1, 0, sigma))
}


N + shift(N, fill=0, type='lag')

trial(data = N)

N[1,]+ shift(N, n=1, fill=0, type="lag")[2]
**********************************************************************

Testing testVectorize2.R...

Output (only first 500 characters): 


**********************************************************************
           [,1]      [,2]      [,3]      [,4]      [,5]      [,6]      [,7]
 [1,] 0.9540087 0.7759196 1.1328076 1.2700750 0.5113972 0.7694249 1.2921152
 [2,] 1.1692821 1.1775936 1.1203184 1.0653132 1.0660898 1.1768732 1.0555112
 [3,] 1.3752391 1.3712694 1.3973911 1.4194496 1.4191612 1.3716158 1.4230293
 [4,] 0.7305880 0.7319576 0.7228825 0.7151117 0.7152138 0.7318383 0.7138421
 [5,] 1.2057365 1.2060131 1.2041022 1.2023178 1.2023422 1.2059892 1.2020132
 [6,] 0.6976428 0.6975712 0.6980648 0.6985245
**********************************************************************

Code ran without errors

Time consumed = 0.65425s

======================================================================
======================================================================
Finished running scripts

Ran into 6 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 99

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!